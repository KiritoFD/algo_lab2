# DNA序列比对算法

本项目实现了一个高效的DNA序列比对算法，使用锚点-图算法进行大规模序列比对，特别适用于包含各种变异（替换、插入、删除、倒位等）的复杂基因组比对任务。

## 算法原理

该算法基于以下关键步骤：

1. **K-mer哈希与锚点生成**：
   - 从参考序列和查询序列中提取所有k-mer
   - 构建哈希表记录参考序列中k-mer的位置
   - 查找匹配的k-mer并合并成连续的锚点

2. **图建模与权重分配**：
   - 将锚点表示为有向图中的节点
   - 根据锚点间的距离和匹配长度分配边权重
   - 添加虚拟起点和终点形成完整图结构

3. **最长路径搜索与动态规划优化**：
   - 使用拓扑排序的动态规划算法找到最长路径
   - 路径代表最优的锚点组合序列

4. **局部精调与结果输出**：
   - 对锚点间区域进行可选的局部序列比对
   - 格式化输出最终的比对结果

## 复杂度分析

| 模块 | 时间复杂度 |
|------|------------|
| **锚点生成** | O(m + n)，其中m和n为序列长度 |
| **图构建** | O(a log a)，其中a为锚点数量 |
| **动态规划** | O(a + e)，其中e为图中的边数 |
| **总复杂度** | 亚平方级，远优于传统动态规划方法 |

## 使用方法

### 安装依赖

```bash
pip install networkx matplotlib numpy
```

### 生成测试数据

```bash
python test_data.py --length 10000 --output test
```

### 运行比对

```bash
python main.py --reference test_ref.fasta --query test_query.fasta --kmer 15 --visualize
```

### 命令行参数

- `-r, --reference`：参考序列文件路径
- `-q, --query`：查询序列文件路径
- `-k, --kmer`：k-mer长度 (默认: 15)
- `-m, --min-anchor`：最小锚点长度 (默认: 20)
- `-v, --visualize`：是否可视化比对结果
- `--reverse`：是否包括反向互补匹配

## 示例

对于以下输入序列：
```
参考序列: "ATGGTACGA---TTC"
查询序列: "ATG---CGAGTATTC"
```

输出结果形式为：
```
锚点 1:
  查询序列位置: 0-3 (长度: 3)
  参考序列位置: 0-3 (长度: 3)
  查询片段: ATG
  参考片段: ATG

锚点 2:
  查询序列位置: 3-6 (长度: 3)
  参考序列位置: 6-9 (长度: 3)
  查询片段: CGA
  参考片段: CGA

锚点 3:
  查询序列位置: 6-10 (长度: 4)
  参考序列位置: 9-13 (长度: 4)
  查询片段: TATTC
  参考片段: TTC
```

## 扩展方向

- **GPU加速**：将哈希查询和动态规划移植到CUDA以提高性能
- **多序列支持**：扩展至多条query序列联合比对
- **错误容忍**：在锚点生成阶段允许一定错配率
- **自适应参数**：根据序列特征自动调整k-mer长度和其他阈值
