# Algorithm Design Document: Sequence Alignment

## 1. Introduction

This document describes the algorithm implemented in `run.py` for aligning a query sequence to a reference sequence. The input to the algorithm is a set of k-mer matches (anchors) between the query and reference, typically generated by a k-mer hashing and lookup process (as seen in `eval.cpp`). The goal is to identify and chain these anchors to form larger, co-linear alignment segments, and then select a consistent, high-scoring set of non-overlapping segments.

The algorithm leverages Numba for JIT compilation of performance-critical sections, specifically anchor chaining and segment selection.

## 2. Algorithm Steps

The core logic of the `function` in `run.py` can be broken down into the following major steps:

### 2.1. Input Processing and Anchor Representation

1.  **Input Data**: The function receives `data` as a NumPy array where each row represents a k-mer match: `(query_start_pos, ref_start_pos, strand, kmersize)`.
2.  **Initial Checks**:
    *   If `data` is empty or not a NumPy array, an empty string is returned.
    *   If `kmersize` (extracted from the first anchor) is invalid (<= 0), an empty string is returned.
3.  **Anchor Creation**:
    *   Each k-mer match is converted into an "anchor" representation. In the Python version, this is a list of dictionaries (`py_anchors`), where each dictionary stores:
        *   `q_s`: Query start position.
        *   `q_e`: Query end position (`q_s + kmersize`).
        *   `r_s`: Reference start position.
        *   `r_e`: Reference end position (`r_s + kmersize`).
        *   `strand`: Strand of the match (1 for forward, -1 for reverse).
        *   `id`: Original index of the anchor (later updated after sorting).
    *   Corresponding NumPy arrays (`q_s_arr`, `q_e_arr`, etc.) are created for efficient use with Numba.
4.  **Sorting Anchors**:
    *   The `py_anchors` list is sorted. The primary sort key is `q_s` (query start position), and the secondary sort key is `r_s` (reference start position).
    *   The NumPy arrays for Numba are then populated based on this sorted order of anchors. This pre-sorting is crucial for the subsequent dynamic programming steps.

### 2.2. Anchor Chaining (`chain_anchors_kernel`)

This step aims to find the optimal (highest scoring) chains of co-linear anchors using dynamic programming. This is performed by the Numba-jitted `chain_anchors_kernel` function.

1.  **Initialization**:
    *   `dp_score`: A NumPy array where `dp_score[i]` will store the maximum score of a chain ending at sorted anchor `i`. Initialized to `kmersize` for each anchor (representing a chain of one anchor).
    *   `parent_idx`: A NumPy array where `parent_idx[i]` will store the index of the anchor that precedes anchor `i` in its optimal chain. Initialized to -1.
2.  **Dynamic Programming**:
    *   The algorithm iterates through each sorted anchor `i` (from 0 to `n_anchors - 1`).
    *   For each anchor `i`, it iterates through all preceding sorted anchors `j` (from 0 to `i - 1`).
    *   **Linking Condition**: Anchor `j` can be linked to anchor `i` if:
        *   They are on the same `strand`.
        *   The gap in query coordinates (`anchor_i_q_s - anchor_j_q_e`) is within `[-MAX_ALLOWED_OVERLAP, MAX_GAP_BETWEEN_ANCHORS]`.
        *   The gap in reference coordinates is also within `[-MAX_ALLOWED_OVERLAP, MAX_GAP_BETWEEN_ANCHORS]`.
            *   Forward strand ref gap: `anchor_i_r_s - anchor_j_r_e`.
            *   Reverse strand ref gap: `anchor_j_r_s - anchor_i_r_e` (note the order due to reverse complement mapping).
        *   The difference in their "diagonals" is less than or equal to `MAX_DIAGONAL_DIFFERENCE`.
            *   Forward strand diagonal for anchor `x`: `x_r_s - x_q_s`.
            *   Reverse strand diagonal for anchor `x`: `x_r_s + x_q_s`.
    *   **Score Update**: If anchor `j` can be linked to anchor `i`, and if the score of the chain ending at `j` plus the score of anchor `i` (`dp_score[j] + kmersize`) is greater than the current `dp_score[i]`, then:
        *   `dp_score[i]` is updated to `dp_score[j] + kmersize`.
        *   `parent_idx[i]` is set to `j`.
3.  **Output**: The kernel returns `dp_score` and `parent_idx` arrays.

### 2.3. Forming Candidate Segments from Chains

After anchor chaining, the algorithm reconstructs these chains and forms candidate alignment segments.

1.  **Iteration and Reconstruction**:
    *   Iterate through each anchor `i` (index in the sorted `py_anchors`).
    *   For each `i`, backtrack using `parent_idx` to reconstruct the chain of anchor indices ending at `i`.
2.  **Segment Creation**:
    *   If the reconstructed chain contains at least `MIN_ANCHORS_PER_CHAIN` anchors:
        *   A candidate segment is formed.
        *   `q_s`: `q_s` of the first anchor in the chain.
        *   `q_e`: `q_e` of the last anchor in the chain.
        *   `r_s`: Minimum `r_s` among all anchors in the chain.
        *   `r_e`: Maximum `r_e` among all anchors in the chain.
        *   `score`: The `dp_score[i]` (score of the chain ending at anchor `i`).
        *   `strand`: The strand of the anchors in the chain.
    *   These candidate segments are collected into a list (`candidate_segments_list`).

### 2.4. Selecting Non-Overlapping Segments (`select_segments_kernel`)

This step selects a globally optimal set of non-overlapping segments from the candidates, again using dynamic programming. This is performed by the Numba-jitted `select_segments_kernel` function.

1.  **Preparation**:
    *   The `candidate_segments` list is sorted. The primary sort key is `q_s`, the secondary key is `-score` (descending score for tie-breaking), and the tertiary key is `q_e`.
    *   NumPy arrays (`seg_q_s_arr`, `seg_q_e_arr`, `seg_scores_arr`) are created from the sorted segments for Numba.
2.  **Initialization**:
    *   `dp_select_score`: A NumPy array where `dp_select_score[i]` will store the maximum score of a set of non-overlapping segments ending with sorted segment `i`. Initialized with the individual scores of the segments.
    *   `prev_select_idx`: A NumPy array where `prev_select_idx[i]` will store the index of the segment that precedes segment `i` in its optimal set. Initialized to -1.
3.  **Dynamic Programming**:
    *   Iterate through each sorted segment `i`.
    *   For each segment `i`, iterate through all preceding sorted segments `j`.
    *   **Non-Overlapping Condition**: Segment `j` can precede segment `i` if `seg_j_q_e <= seg_i_q_s` (segment `j` ends before or at the start of segment `i` in the query).
    *   **Score Update**: If segment `j` can precede segment `i`, and if `dp_select_score[j] + seg_i_score` (score of set ending at `j` plus score of segment `i`) is greater than `dp_select_score[i]`, then:
        *   `dp_select_score[i]` is updated.
        *   `prev_select_idx[i]` is set to `j`.
4.  **Path Reconstruction**:
    *   Find the segment `best_end_idx` that has the maximum `dp_select_score`.
    *   Backtrack using `prev_select_idx` from `best_end_idx` to reconstruct the list of indices of the selected segments. This list is initially in reverse order.
5.  **Output**: The kernel returns the list of selected segment indices (in reverse order).

### 2.5. Final Output Formatting

1.  **Reversing Selected Indices**: The list of indices returned by `select_segments_kernel` is reversed in Python to get the correct order.
2.  **Segment Retrieval**: The actual segment dictionaries are retrieved from `filtered_segments_py` using the selected indices.
3.  **String Formatting**: The coordinates (`q_s`, `q_e`, `r_s`, `r_e`) of these final selected segments are concatenated into a single comma-separated string.

## 3. Key Parameters

The algorithm's behavior is controlled by several parameters:

*   `kmersize` (int): The size of the k-mers used for initial matching. Derived from input data.
*   `max_gap_param` (int, default: 250): The maximum allowed gap (in base pairs) between the end of one anchor and the start of the next in a chain, for both query and reference sequences.
*   `max_diag_diff_param` (int, default: 150): The maximum allowed difference between the diagonals of two anchors for them to be considered co-linear and part of the same chain.
*   `overlap_factor_param` (float, default: 0.5): A factor used to calculate `MAX_ALLOWED_OVERLAP`. `MAX_ALLOWED_OVERLAP = int(kmersize * overlap_factor_param)`. This defines how much anchors can overlap and still be chained.
*   `min_anchors_param` (int, default: 1): The minimum number of anchors required to form a valid chain that can be considered a candidate segment.

## 4. Numba JIT Compilation

The functions `chain_anchors_kernel` and `select_segments_kernel` are decorated with `@numba.njit`. This compiles these Python functions (with NumPy operations) down to efficient machine code, significantly speeding up the most computationally intensive parts of the algorithm. These functions operate primarily on NumPy arrays.

## 5. Summary

The algorithm employs a multi-stage process:
1.  Identifies and sorts initial k-mer matches (anchors).
2.  Uses dynamic programming to chain co-linear anchors into longer potential alignments.
3.  Forms candidate segments from these chains.
4.  Uses another dynamic programming step to select a high-scoring, non-overlapping set of these candidate segments.
5.  Outputs the selected segments as a formatted string.

The use of Numba and careful sorting are key to achieving reasonable performance. The parameterization allows for tuning the algorithm's sensitivity and stringency.
